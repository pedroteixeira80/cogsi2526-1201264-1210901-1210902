# cogsi2526-1210901-1210902

# CA4 -  Configuration Management

The following steps outline the implementation of the solution:
### Create an inventory
1. Create an inventory file, for example, hosts.ini.
2. Define the VMs in the inventory file.
    ```ini
    [app]
    192.168.56.12 ansible_user=vagrant ansible_ssh_private_key_file=/home/vagrant/.ssh/app_key

    [db]
    192.168.56.11 ansible_user=vagrant ansible_ssh_private_key_file=/home/vagrant/.ssh/db_key
    ```
The inventory file defines two groups, app and db, with the IP addresses of the VMs and the SSH private key files for authentication.
These key files are generated by Vagrant and are used to authenticate the Ansible control node with the VMs.

### Steps for the app playbook
1. Create a yml file, for example app.yml.
   2. Translate the previous CA3/part2 implementation into the playbook. The next tasks are the translation of the previous provision_app.sh implementation into the playbook.
       1. **Install the necessary dependencies.**
          ```yml
             - name: Install dependencies
               apt:
                name:
                 - openjdk-17-jdk
                 - git
                 - netcat-openbsd
                 - curl
                 - wget
                 - unzip
                 - net-tools
               state: present
           ```
       2. **Clone the Spring Boot application from GitHub.**
           ```yml
           - name: Clone Spring Boot application repository
             shell: |
              git clone https://{{ lookup('env', 'GITHUB_TOKEN') }}@github.com/pedroteixeira80/cogsi2526-1201264-1210901-1210902.git /home/vagrant/app
             args:
              creates: /home/vagrant/app
             become: yes
             become_user: vagrant
             environment:
              GIT_TERMINAL_PROMPT: '0'
             register: git_clone
             failed_when: git_clone.rc != 0 and git_clone.rc != 128
            ```
       3. **Create application.properties directory**
           ```yml
           - name: Create application properties directory
             file:
              path: "/home/vagrant/app/CA2-part2/tut-gradle/src/main/resources"
              state: directory
              mode: '0755'
           ```
       4. **Create application.properties file**
          ```yml
          - name: Configure application.properties
            copy:
             dest: "/home/vagrant/app/CA2-part2/tut-gradle/src/main/resources/application.properties"
             content: |
              # H2 Database Configuration (Remote DB Server)
              spring.datasource.url=jdbc:h2:tcp://192.168.56.11:9092/home/vagrant/h2_data/jpadb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
              spring.datasource.driverClassName=org.h2.Driver
              spring.datasource.username=sa
              spring.datasource.password=
           
              # JPA Configuration
              spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
              spring.jpa.hibernate.ddl-auto=update
           
              # H2 Console Configuration
              spring.h2.console.enabled=true
              spring.h2.console.path=/h2-console
              spring.h2.console.settings.web-allow-others=true
           
              # Spring Data REST
              spring.data.rest.base-path=/api
          ```
       5. **Wait for the database to be up and running.**
           ```yml
           - name: Wait for DB server to be ready
             wait_for:
               host: "192.168.156.11"
               port: "9092"
               delay: 5
               timeout: 300
               state: started
           ```
       6. **Build application directory is executable**
           ```yml
          - name: Build the application
            shell: "./gradlew clean build -x test"
            args:
             chdir: "/home/vagrant/app/CA2-part2/tut-gradle"
            become: yes
            become_user: vagrant
            environment:
             HOME: /home/vagrant
           ```
       7. **Start the application.**
           ```yml
           - name: Start Spring Boot application
             shell: "nohup ./gradlew bootRun > /home/vagrant/spring-app.log 2>&1 & echo $! > /home/vagrant/spring-app.pid"
             args:
              chdir: "/home/vagrant/app/CA2-part2/tut-gradle"
             become: yes
             become_user: vagrant
             environment:
              HOME: /home/vagrant
           ```

       8. **Application health-check**
            ```yml
           - name: Health check - Verify Spring Boot is responding
             uri:
              url: http://localhost:8080
              method: GET
              status_code: 200
             retries: 5
             delay: 5
             register: health_check
             until: health_check.status == 200
           ```

### Steps for the db playbook
1. Create a yml file, for example db.yml.
2. Translate the previous CA3/part2 implementation into the playbook. The next tasks are the translation of the previous provision_db.sh implementation into the playbook.
    1. **Install the necessary dependencies.**
       ```yml
        - name: Install OpenJDK 17, unzip, and net-tools
          apt:
           name:
            - openjdk-17-jdk
            - unzip
            - net-tools
          state: present
        ```
    2. **Check if H2 directory exists**
       ```yml
         - name: Check if H2 directory exists
           stat:
             path: /opt/h2
           register: h2_dir
       ```
    3. **Download and extract H2 database**
       ```yml
       - name: Download and extract H2 database
         when: not h2_dir.stat.exists
         block:
          - name: Download H2 database JAR
            get_url:
             url: https://repo1.maven.org/maven2/com/h2database/h2/2.1.214/h2-2.1.214.jar
             dest: /opt/h2.jar
             mode: '0644'
          
          - name: Create H2 directory
            file:
              path: /opt/h2
              state: directory
              mode: '0755'
      
          - name: Move H2 JAR to directory
            command: mv /opt/h2.jar /opt/h2/h2.jar
            args:
              creates: /opt/h2/h2.jar
       ```

   4. **Start H2 database**
       ```yml
        - name: Start H2 database
          shell: |
           nohup java -cp /opt/h2/h2.jar org.h2.tools.Server \
            -tcp -tcpAllowOthers -tcpPort 9092 \
            -web -webAllowOthers -webPort 8082 \
            -baseDir /home/vagrant/h2_data \
            -ifNotExists > /home/vagrant/h2-server.log 2>&1 &
            echo $! > /home/vagrant/h2-server.pid
          args:
           chdir: /home/vagrant
           executable: /bin/bash
          become: yes
          become_user: vagrant
          environment:
           HOME: /home/vagrant
       ```
   5. **Install UFW (Uncomplicated Firewall)**
       ```yml
        - name: Install UFW (Uncomplicated Firewall)
          apt:
            name: ufw
            state: present
       ```
   6. **Set UFW default policy to deny incoming connections**
       ```yml
        - name: Set UFW default policy to deny incoming connections
          ufw:
          default: deny
          direction: incoming
       ```
   7. **Set UFW default policy to allow outgoing connections**
        ```yml
           - name: Set UFW default policy to allow outgoing connections
             ufw:
             default: allow
             direction: outgoing
        ```
    8.  **Allow incoming connections on port 9092**
          ```yml
          - name: Allow connections to H2 database port (9092) from app VM (192.168.56.12)
            ufw:
            rule: allow
            proto: tcp
            from_ip: 192.168.56.12
            port: "9092"  # Quoted to avoid type warning
          ```
   9. **Enable UFW**
        ```yml
        - name: Enable UFW
          ufw:
          state: enabled
         ```
      
   10. **Check that the H2 database socket or port is open and accepting connection**
        ```yml
       - name: Health check - Verify H2 database port is accepting connections
         wait_for:
          host: 0.0.0.0
          port: 9092
          state: started
          timeout: 10
         register: db_health
         retries: 3
         delay: 5
         until: db_health is succeeded
         
       - name: Health check - Verify H2 web console is accessible
         wait_for:
          host: 0.0.0.0
          port: 8082
          state: started
          timeout: 10
         register: console_health
         retries: 3
         delay: 5
         until: console_health is succeeded
       ```

### Playbooks
### Running the playbooks
The playbooks can be run locally using the following commands, but you must have ansible installed in your local machine:
1. Run the db playbook first to set up the H2 database.
    ```bash
    ansible-playbook -i hosts.ini db.yml
    ```
2. Run the app playbook to set up the Spring Boot application.
    ```bash
    ansible-playbook -i hosts.ini app.yml
    ```
Another way to use the playbooks is by implementing them in a vagrant file. This can be done by reusing the CA3/part2 Vagrantfile and modifying the configuration as shown bellow:

1. Add the following lines to the Vagrantfile to setup the ssh keys, same as CA3/part2:
    ```ruby
        Vagrant.configure("2") do |config|
          # Provisioning private key for app
          config.vm.provision "file",
            source: "~/.ssh/app_key",
            destination: "/home/vagrant/.ssh/app_key"
        
          # Provisioning private key for db
          config.vm.provision "file",
            source: "~/.ssh/db_key",
            destination: "/home/vagrant/.ssh/db_key"
        
          # SSH private key paths
          config.ssh.private_key_path = [
            "~/.vagrant.d/insecure_private_key",
            "~/.ssh/app_key",
            "~/.ssh/db_key"   
          ]
    ```
2. Add the following synced folder to save the db data:
    ```ruby
       config.vm.synced_folder "./h2_data", "/home/vagrant/h2_data"
    ```
3. Add the following lines to the Vagrantfile to run the db playbook:
    ```ruby
    config.vm.define "db" do |db|
     db.vm.box = "bento/ubuntu-22.04"
     db.vm.network "private_network", ip: "192.168.56.11"
     db.vm.provider "virtualbox" do |vb|
      vb.memory = "1024"
      vb.cpus = 1
     end
     db.vm.provision "file",
      source: "~/.ssh/db_key.pub",
      destination: "~/.ssh/authorized_keys"
     db.vm.provision "shell", inline: <<-SHELL
      chmod 600 /home/vagrant/.ssh/db_key
     SHELL
     db.vm.provision "ansible_local" do |ansible|
      ansible.playbook = "db_playbook.yml"
      ansible.inventory_path = "hosts.ini"
      ansible.extra_vars = { host: "db" }
      ansible.compatibility_mode = "2.0"
      ansible.raw_arguments = ["--ssh-extra-args='-o StrictHostKeyChecking=no'"]
     end
    end
    ```

4. Add the following lines to the Vagrantfile to run the app playbook:
    ```ruby
      config.vm.define "app" do |app|
       app.vm.box = "bento/ubuntu-22.04"
       app.vm.network "private_network", ip: "192.168.56.12"
       app.vm.network "forwarded_port", guest: 8080, host: 8080
       app.vm.provider "virtualbox" do |vb|
         vb.memory = "2048"
         vb.cpus = 2
       end
       app.vm.provision "file",
           source: "~/.ssh/app_key.pub",
           destination: "~/.ssh/authorized_keys"
       app.vm.provision "shell", inline: <<-SHELL
        chmod 600 /home/vagrant/.ssh/app_key
       SHELL
       app.vm.provision "ansible_local" do |ansible|
         ansible.playbook = "app_playbook.yml"
         ansible.inventory_path = "hosts.ini"
         ansible.extra_vars = { host: "app" }
         ansible.compatibility_mode = "2.0"
         ansible.raw_arguments = ["--ssh-common-args='-o StrictHostKeyChecking=no'"]
       end
end
    ``` 
In the Vagrantfile, the db and app VMs are defined, and the db and app playbooks are provisioned to the respective VMs. The SSH keys are also provisioned to the VMs to allow Ansible to connect to them. The compatibility mode is set to 2.0 to avoid errors, and the SSH arguments are specified to avoid known_hosts errors.
You can notice that ansible_local is used, this is done since installing Ansible in the local host is difficult, so it is better to use the ansible_local provisioner installed in the VMs by Vagrant.

### Testing the solution
1. Run the Vagrantfile to create the VMs and provision them with the playbooks.
    ```bash
    vagrant up
    ```
2. Access the Spring Boot application by opening a web browser and navigating to http://192.168.56.12:8080/employees
   ![employees.png](images/employees.png)
3. Due to the firewall rules set up by UFW, the H2 database console is not accessible from the host machine. To modify this behavior, you can add a rule to allow connections to port 8082 in the db playbook. After adding the rule, you can access the H2 database console by opening a web browser and navigating to http://192.168.56.12/8082:
   ![h2-console.png](images/h2-console.png)

## Enforcing Complex Password Policies with PAM Configuration Using Ansible
To strengthen system security, it's essential to enforce password complexity rules such as minimum length, mandatory character types, and retry limits. This guide leverages the pam_pwquality module to implement these rules and uses Ansible for automation.

### Playbook Details:
1. **Install PAM Dependencies**: The first task ensures that the required PAM module, libpam-pwquality, is installed on the target systems.
    ```yml
    - name: Install PAM dependencies
      apt:
        name: "libpam-pwquality"
        state: present
        update_cache: yes
   ```
   **. What it does**:

    - Installs libpam-pwquality, which provides advanced password quality enforcement.
    - Updates the package cache to ensure the latest version is installed.

2. **Configure pam_pwquality Rules**: The second task modifies the /etc/pam.d/common-password file to enforce password complexity.
    ```yml
    - name: Configure pam_pwquality
      lineinfile:
       path: "/etc/pam.d/common-password"
       regexp: "pam_pwquality.so"
       line: "password required pam_pwquality.so minlen=12 lcredit=-1 ucredit=-1 dcredit=-1 ocredit=-1 retry=3 enforce_for_root"
       state: present
      ```
   **. Explanation of Rules**:

    - ***minlen***=12: Passwords must be at least 12 characters long.
    - ***minclass***=3: at least 3 of 4 character classes (upper, lower, digit, symbol)
    - ***lcredit***=-1: Requires at least one lowercase letter.
    - ***ucredit***=-1: Requires at least one uppercase letter.
    - ***dcredit***=-1: Requires at least one digit.
    - ***ocredit***=-1: Requires at least one special character.
    - ***usercheck***=1: disallow passwords containing username or parts of it.
    - ***dictcheck***=1: reject common dictionary words.
    - ***enforce_for_root***: Enforces these rules even for the root user.
   
3. **Prevent reuse of the last five passwords**:
    ```yml
    - name: Ensure pam_unix prevents password reuse
      lineinfile:
        path: "/etc/pam.d/common-password"
        regexp: "pam_unix.so"
        line: "password sufficient pam_unix.so sha512 shadow remember=5"
        state: present
      ```

4. **Ensure the account is locked for ten minutes after five consecutive failed login attempts**:
    ```yml
    - name: Configure account lockout policy (faillock)
      lineinfile:
        path: "/etc/pam.d/common-auth"
        insertafter: "pam_env.so"
        line: |
          auth required pam_faillock.so preauth silent deny=5 unlock_time=600
          auth [default=die] pam_faillock.so authfail deny=5 unlock_time=600
        state: present
      ```

### Running the playbook
The playbooks can be run locally using the following commands, but you must have ansible installed in your local machine:

1. Execute the playbook using the following command:
    ```bash
    ansible-playbook configure_pam.yml -i Vagrantfile
    ```

### Benefits of Using PAM Configuration with Ansible
- **Automation**: Apply password policies across multiple systems with minimal effort.
- **Consistency**: Ensures uniform security settings on all servers.
- **Efficiency**: Reduces manual configuration, minimizing errors and saving time.


## Setting Up Secure Application and Database Access for Developers Group Using Ansible

In a secure development environment, controlling access to application and database resources is vital. This guide uses Ansible to automate the creation of a developers group, add a user to that group, and enforce restricted access to key directories.

### Playbook Details
1.  **Create the Developers Group**:
    The first task ensures the existence of a developers group, simplifying access management for multiple users.
    ```yml
    - name: Create developers group
      group:
        name: developers
        state: present
      ```   

2.  **Add User devuser to the Developers Group**:

    Create a new user, devuser, and assign them to the developers group.
    ```yml
    - name: Create devuser user and add to developers group
      user:
        name: devuser
        groups: developers
        append: yes
        state: present
    ```
    #### Key Points
    - **append: yes:** :
      Ensures the user remains part of any previously assigned groups while adding them to developers.
    - This task ensures seamless role assignment without overwriting other user group memberships.


3. **Make spring application and database directory only accessible to members of the developers group**:

   ```yml
    - name: Set ownership of app directory to developers group
      file:
        path: /home/vagrant/app
        owner: devuser
        group: developers
        mode: '0750' #means only owner (vagrant) and group (developers) can access
        recurse: yes
      become: yes
      when: "'app' in group_names"
      
    - name: Set ownership of h2_data directory to developers group
      file:
        path: /home/vagrant/h2_data
        owner: vagrant
        group: developers
        mode: '0750'
        recurse: yes
      become: yes
      when: "'db' in group_names" # Ignores errors if the directories don't exist    
   ```
   #### Details
    - **mode: '0750'**:
      Provides read, write, and execute permissions for the owner, read and execute permissions for the group, and no access for others.
    - **recurse: yes**:
      Iterates over the specified directories.

## Adding the Create Users and PAM Playbooks to the Vagrantfile
To integrate the create_users.yml and configure_pam.yml playbooks into the vagrant file, the following steps can be followed:
1. **Create a new playbook app_playbook.yml**:
    - In this new playbook use the import_tasks module to include the app, create_users.yml and configure_pam.yml playbooks, like shown bellow:
        ```yml
       - hosts: app
         become: yes
         tasks:
          - import_tasks: app.yml
          - import_tasks: configure_pam.yml
          - import_tasks: configure_users.yml
          - import_tasks: configure_permissions.yml
       ```
2. **Create a new playbook db_playbook.ym**:
    - In this new playbook use the import_tasks module to include the db, create_users.yml and configure_pam.yml playbooks, like shown bellow:
       ```yml
       - hosts: db
         become: yes
         tasks:
       - import_tasks: db.yml
       - import_tasks: configure_pam.yml
       - import_tasks: configure_users.yml
       - import_tasks: configure_permissions.yml
       ```
3. **Modify the Vagrantfile**:
    - Modify the lines where app.yml and db.yml are provisioned to include the new playbooks, like shown bellow:
      ```ruby
      ansible.playbook = "db_playbook.yml"
      ansible.playbook = "app_playbook.yml"
      ```
4. **Run the vagrant file**:
    - Run the vagrant file to create the VMs and provision them with the playbooks.
      ```bash
       vagrant up
      ```

### Testing the PAM and User Configuration Playbooks

1. **Accessing the devuser Account**:
   To switch to the devuser account with superuser privileges, use the following command:
    ```bash
    sudo -su devuser
    ```
2. **Listing Directory Contents in /home/vagrant/app**:
   To inspect the files and directories under /home/vagrant/app, use the following command:
    ```bash
    ls -la /home/vagrant/app/
    ```
   The expected output should display the permissions, ownership, and groups for each item within the /home/vagrant/app directory.

4. **Verifying User Group and Account Information**:
   These commands will display the group information and user account details for devuser. The developers group should list devuser as a member, with the expected GID (Group ID) and UID (User ID) specified in the output.

5. **Enforcing Password Complexity Requirements**:
   To ensure strong password policies, the system is configured to use libpam-pwquality. This package enforces complexity requirements on user passwords. To verify if libpam-pwquality is installed, use:
    ```bash
    dpkg -l | grep libpam-pwquality
    ```
   
6. **Changing Password for devuser**:
   To apply these password policies, attempt to change devuserâ€™s password using:
    ```bash
    sudo passwd devuser
    ```
   If the entered password does not meet the complexity requirements, an error will be displayed, indicating the specific criteria that were not met. This ensures all user passwords align with the system's security policies.


## Ansible Alternative
